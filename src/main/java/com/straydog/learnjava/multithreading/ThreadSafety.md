# JAVA线程安全

## 什么是线程安全?

如果某段代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。
如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，
就是**线程安全**的。

- 线程安全的代码
   - **允许被多个线程**同时执行的代码称作线程安全的代码;
   - 线程安全的代码**不包含竞态条件**。当多个线程同时更新共享资源时会引发**竞态条件**

## 基础概念

### 线程控制逃逸规则

如果一个资源的**创建**，**使用**，**销毁**都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是**线程安全**的。

### 产生资源竞态的条件


当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，**才会产生竞态条件**。

多个线程**同时读**同一个资源**不会**产生竞态条件。

### 临界区

在同一程序中运行多个线程本身不会导致问题，问题在于**多个线程访问了相同的资源**。
(如：同一内存区（变量，数组，或对象）、系统（数据库，web services 等）或文件)。


实际上，这些问题只有在一或多个线程向这些资源做了**写操作时才有可能发生**，
只要资源没有发生变化,多个线程读取相同的资源就是安全的。

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作**临界区**。

## 并发编程中的三个概念
1. 原子性

- 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

2. 可见性

- 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

3. 有序性

- 即程序执行的顺序按照代码的先后顺序执行

## Java如何保证线程安全

- 设计线程安全类流程：

   1. 找出构成对象状态的所有变量。

   2. 找出约束状态变量的不变性条件。

   3. 建立对象状态的并发访问管理策略。

### 解决线程安全的办法

1. 加锁(同步代码块)

- 当一段代码会修改共享变量，这一段代码成为互斥区或临界区，为了保证共享变量的正确性，`synchronized`标示了临界区

   1. 锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。

   2. 加锁时需要考虑性能问题，不能总是一味地给整个方法加锁`synchronized`就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。

   3. 加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。

   - 加锁的用法

      1. `sychronized method(){}`

      2. `sychronized (objectReference) {/*block*/}`

      3. `static synchronized method(){}`

      4. `sychronized(classname.class)`


- 理论上，每个对象都可以做为锁，但一个对象做为锁时，应该被多个线程共享，这样才显得有意义，在并发环境下，一个没有共享的对象作为锁是没有意义的

```java
public class ThreadTest{
  public void test(){
     //lock变量作为一个锁存在根本没有意义，因为它根本不是共享对象，每个线程进来都会执行`Object lock=new Object()`;每个线程都有自己的`lock`，根本不存在锁竞争。
     Object lock=new Object();
     synchronized (lock){
        //do something
     }
  }
}
```


   > 同步是一种高开销的操作，因此应该尽量减少同步的内容

2. 不共享状态

3. 不可变对象


## 一个临界区代码的执行过程

1. 获得同步锁
2. 清空工作内存
3. 从主存拷贝变量副本到工作内存
4. 对这些变量计算
5. 将变量从工作内存写回到主存
6. 释放锁

> 可见，`synchronized` 既保证了多线程的并发有序性，又保证了多线程的内存可见性。

